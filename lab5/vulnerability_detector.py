import requests

# Target configuration
target = "http://localhost:3000"

# Endpoints and injections for testing
enpoints = [
    "/", 
    "/rest/products/search", 
    "/rest/user/login", 
    "/api/Feedbacks", 
    "/rest/basket", 
    "/ftp", 
    "/api/Products"
    ]

injections = [
    ("normal", "apple"),
    ("xss", "<script>alert(1)</script>"),
    ("xss", "<u>test</u>"),
    ("xss", '<<script>Foo</script>iframe src="javascript:alert(`xss`)">'),
    ("sqli", "' OR 1=1 --"),
    ("sqli", "'")
]

def print_header(text):
    print("\n" + "="*80)
    print(f"{text:^80}")
    print("="*80)

def run_standalone_detector():
    findings = []
    headers_audited = False

    print(f"Targeting: {target}")

    for endpoint in enpoints:
        url = f"{target}{endpoint}"
        
        for payload_type, payload_sent in injections:
            # get and post because more is better
            for method in ["GET", "POST"]:
                try:
                    if method == "GET":
                        res = requests.get(url, params={'q': payload_sent}, timeout=5)
                    else:
                        res = requests.post(url, json={"email": payload_sent, "password": payload_sent, "comment": payload_sent}, timeout=5)

                    if not headers_audited:
                        # SSL/TLS check
                        if target.startswith("http://"):
                            findings.append("[LOW] SSL/TLS WEAKNESS: Site uses unencrypted HTTP. HTTPS is required.")
                        
                        # Security Headers check
                        security_headers = {
                            "Content-Security-Policy": "Mitigates XSS",
                            "Strict-Transport-Security": "Enforces HTTPS",
                            "X-Content-Type-Options": "Prevents sniffing missing"
                        }
                        for header, desc in security_headers.items():
                            if header not in res.headers:
                                findings.append(f"[LOW] MISSING HEADER: {header} ({desc})")
                        
                        # other leakage
                        server = res.headers.get("Server")
                        powered_by = res.headers.get("X-Powered-By")
                        if server:
                            findings.append(f"[INFO] LEAKAGE: Server header reveals '{server}'")
                        if powered_by:
                            findings.append(f"[INFO] LEAKAGE: X-Powered-By header reveals '{powered_by}'")
                        
                        headers_audited = True # Ensures we only report config issues once

                    # using the provided reflector logic
                    if payload_type == "xss" and payload_sent in res.text:
                        findings.append(f"[HIGH] XSS DETECTED: {endpoint} reflected {payload_sent} (Method: {method})")


                    # using provided sqli logic
                    if payload_type == "sqli":
                        db_errors = ["SQLITE_ERROR", "Table not found", "syntax error", "Unexpected token"]
                        if any(error in res.text for error in db_errors) or res.status_code == 500:
                            findings.append(f"[CRITICAL] SQLi ERROR: {endpoint} flagged via {payload_sent}")
                        
                        # check for login
                        elif res.status_code == 200 and "/login" in endpoint:
                            findings.append(f"[CRITICAL] SQLi BYPASS: Potential login success at {endpoint}")

                except requests.RequestException as e:
                    print(f"[!] Connection error at {endpoint}: {e}")

    print_header("VULNERABILITY SUMMARY REPORT")
    
    # removing duplicates.
    unique_findings = sorted(list(set(findings)))
    
    if unique_findings:
        for issue in unique_findings:
            print(issue)
    else:
        print(" no issues ")
    
    print("-" * 80)
    print(f"number of issues found: {len(unique_findings)}")
    print("=" * 80)

if __name__ == "__main__":
    run_standalone_detector()